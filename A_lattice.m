function [T,R,neighbour]=lattice(a,m,n,varargin)
    
%% GENERATION OF LATTICE NODES SORTED BY GROWING NORM:
%% [-] INSIDE A RADIUS EQUAL TO m TIMES THE DIAMETER OF
%%     THE SMALLEST SPHERE CONTAINING THE PRIMITIVE CELL
%% [-] WITHIN COMPLETE SHELL OF n-TH  NEIGHBOURS
    
%% Definitions:

%% Spanned primitive cell 
% = primitive cell spanned by the basis vectors so that 
% the origin is a corner of this cell.
% The corners of this cell match lattice nodes.
%
%% Centered primitive cell
% = primitive cell centered on a lattice node that is also 
% the only node contained in the cell. 
% The corners of this cell do not match any lattice node.
% This is viewed by considering the corners of the primitive cell 
% centered at the origin that are obtained by adding the vector -s 
% to the corners of the spanned primitive cell, where s is the
% center of the spanned primitive cell defined by
% s = (a(1:3,1) + a(1:3,2) + a(1:3,3))/2
% (equivalent to changing the origin to s).
%
%% Wigner-Seitz primitive cell
%  = primitive cell such that all points inside the cell are closer
%  to the node at the center of the cell than to any other node.
%  This concept is not used when generating lattices.

%% Inputs:
%
%  a = 3X3 array of lattice basis vectors in column order
%      and in arbitrary unit of length
%
%      a(1:3,1) = lattice basis vector 1,
%      a(1:3,2) = lattice basis vector 2,
%      a(1:3,3) = lattice basis vector 3.
%
%  m > 0 (integer)
%    = minimum number of spanned primitive cells in any direction,
%      thereby meaning a minimum number of m-1/2 centered primitive
%      cells in any direction
%      NB: setting m=1 will surely generate first & second neighbours
%
%  n > 0 (integer)
%    = number of requested complete shells of neighbours
    
%% Outputs
%
%  T(1:5,i) lattice nodes inside a radius equal 
%           to m times the diameter of the smallest sphere 
%           that can contain the primitive cell;
%           sorted by growing norm;
%           in same unit of length as input array a
%  where:
%      T(1:3,i) = Cartesian coordinates of lattice vector i,
%      T(4,i)   = norm of lattice vector i,
%      T(5,i)   = square of norm of lattice vector i.   
%    
%  R(1:5,j) subset of T containing only the nodes inside the n-th
%           shell of neighbours
%
%  neighbour(:)       = array
%  neighbour(1)       = 2  <=> R(1:5,2) = start of the first neighbour shell
%  neighbour(1<k<n)   = L  <=> R(1:5,L) = start of the k-th  neighbour shell
%  neighbour(n)       = length(R) = total number of nodes inside
%                                   n-th shell of neighbours
%
%  neighbour(2)  - neighbour(1)   = number of first  neighbours
%  neighbour(3)  - neighbour(2)   = number of second neighbours
%  neighbour(k+1)- neighbour(k)   = number of k-th   neighbours (1<k<n)
%  neighbour(n+1)- neighbour(n)+1 = number of n-th   neighbours

%% Recognized options in varargin 
% (uppercases for readability are optional): 

% 'Direct': work in direct space (default)
% 'Recip' : work in reciprocal space (this will only change labels
%           of optional plots)
% 'PlotBasisVectors'   to plot basis vectors of the lattice
% 'PlotPrimitiveCell'  to plot the primitive cell 
%                      spanned by the basis vectors
% 'PlotPrimitiveCellCentered'  to plot the primitive cell 
%                              centered at the origin
% 'PlotLatticeNodes'   to plot the lattice nodes generated by the
%                      function
% 'ShellTable' to display table of shell orders, their start index
%                               and their number of nodes
% 'Verbose'    to display some computation details
% if varargin{k} = 'Colors', then varargin{k+1 } = 7x3 matrix
%                            = Color order of successive objects
% if varargin{k} = 'ColorMap', 
%                   then varargin{k+1} = Character string 
%                   defining one of the pre-defined colormaps
%                   used to plot the spanned primitive cell's faces
% if varargin{k} = 'ShowLegend', 
%                   then varargin{k+1} = Boolean to show legend or
%                   not    
    
%% DEFAUT VALUES OF OPTIONAL ARGUMENTS

default_color=true; color_map='default'; show_legend=true; 
shelltable=false; verbose=false;
space='direct';
plot_basis_vectors = false;
plot_primitive_cell = false;
plot_primitive_cell_centered = false;
plot_lattice_nodes = false;
bvec{1}='a_1';bvec{2}='a_2';bvec{3}='a_3';
coord{1}='x_1';coord{2}='x_2';coord{3}='x_3';
    
%% PARSE OPTIONAL ARGUMENT LIST

name_value_pair=false;
for k = 1:length(varargin);
    if (name_value_pair)
        name_value_pair=false;
    else
        switch lower(varargin{k}) % varargin is a "cell array"
          case {'direct'}
            space='direct'; Title='Direct lattice';
            bvec{1} ='a_1';bvec{2} ='a_2'; bvec{3}='a_3';
            coord{1}='x_1';coord{2}='x_2';coord{3}='x_3';
          case {'recip'}
            space='recip'; Title='Reciprocal lattice';
            bvec{1} ='g_1';bvec{2} ='g_2'; bvec{3}='g_3';
            coord{1}='q_1';coord{2}='q_2';coord{3}='q_3';
          case {'plotbasisvectors'}
            plot_basis_vectors = true; 
          case {'plotprimitivecell'}
            plot_primitive_cell = true; 
          case {'plotprimitivecellcentered'}
            plot_primitive_cell_centered = true; 
          case {'plotlatticenodes'}
            plot_lattice_nodes = true; 
          case {'shelltable'}
            shelltable = true; 
          case {'verbose'}
            verbose = true; 
          case {'colors'}
            color_scheme = varargin{k+1}; default_color=false; 
            name_value_pair=true;
          case {'colormap'}
            color_map=varargin{k+1}; name_value_pair=true; 
          case {'showlegend'}
            show_legend=varargin{k+1}; name_value_pair=true;
          otherwise
            error(['function lattice: ',...
                   'option %s not recognized.\n'],...
                  varargin{k}); 
        end
    end
end

%% PRECISION

tol = 1e-12; % Two floating-point numbers will be considered equal 
             % if the absolute value of their difference is < tol

%% GENERATE LATTICE


nth=0;
for k=0:1
    for j=0:1
        for i=0:1
            nth=nth+1; % Vertices of spanned primitive cell
            vertex(1:3,nth)=i*a(1:3,1)+j*a(1:3,2)+k*a(1:3,3);
        end
    end
end

nth=0; radius=0;
for j=1:8
    for i=j+1:8
        nth=nth+1;
        b(1:3)=vertex(1:3,i)-vertex(1:3,j); b(4) = norm(b(1:3));
        if (b(4) > radius)
            radius = b(4);
        end
    end
end

% radius = Largest length inside spanned primitive cell
%        = Diameter of smallest sphere that can contain
%          the spanned primitive cell
radius=m*radius;   % Radius surely including in any direction:
                   % [-] AT LEAST m spanned primitive cells
                   % [-] AT LEAST m-1/2 centered primitive cells

for i=1:3 % Try to fill all directions as homogenously as possible
    if (norm(a(:,i))>tol) % Check for 1D or 2D input basis vectors
        l(i)=ceil(radius/norm(a(:,i))); % => 2*l(i)+1 steps in
                                        % direction i
    else
        l(i)=0; % No step in direction i
    end
end

nb=0;
for i=-l(1):l(1)
    for j=-l(2):l(2)
        for k=-l(3):l(3)
            v(1:3)=i*a(1:3,1)+j*a(1:3,2)+k*a(1:3,3);
            v(5)= v(1)^2+v(2)^2+v(3)^2;
            v(4)= sqrt(v(5));
            if (v(4)<=radius)   % Generate nodes only inside radius
                nb=nb+1;
                R(1:5,nb)= v(1:5);
            end
        end
    end
end

R=sortrows(R',4)'; % Sorting lattice vectors by growing norm

T=R; % Store all generated nodes inside radius  

%% Find shells of neighbours

neighbour(1:n+1)=0;
reference=R(5,1); k=0; 
for i=2:nb
    if(R(5,i)>reference+tol)
        k=k+1; neighbour(k)=i; % Shell of k-th neighbours
                               % detected to start with R(1:5,i)
        reference=R(5,i);
    end
end

%% EPILOG

nT=length(neighbour); fprintf('\n')
if(verbose)
    fprintf(['Function lattice generated inside a radius = %d:\n' ...
             '    %d lattices nodes inside the radius containing\n' ...
             '    at least %d spanned primitive cell(s) in any direction\n', ...
             '    <=> inside the radius = %d times the diameter\n' ...
             '    of the smallest sphere containing the primitive cell.\n\n'], ...
            radius,nb,m,m);
end

if (shelltable)
    fprintf('Shell | Start | Nb of\n')
    fprintf('order | index | Nodes\n')
    shellnodes(1)=neighbour(1)-1;
    fprintf(' %4d  %6d  %6d\n',0,1,shellnodes(1))
    for i=2:nT-1
        shellnodes(i)=neighbour(i)-neighbour(i-1);
        fprintf(' %4d  %6d  %6d\n',i-1,neighbour(i-1),shellnodes(i))
    end
    fprintf(' %4d  %6d  %6d\n',nT-1,neighbour(n),columns(R)- ...
            neighbour(i)+1)
    if (neighbour(n+1)==0)
        fprintf(' %4d  %6d  %6d\n',nT,NaN,0)
    end
end

if (neighbour(n+1)==0)
    fprintf(['\nWARNING: in function lattice, requested shell order %d\n' ...
             '         might be incomplete ' ...
             'because start of shell order %d not detected!\n'],n, n+1)
    if(~shelltable)
        fprintf(['            Use option "ShellTable" to view ' ...
                 'details.\n']) 
    end
   % T=[]; R=[]; neighbour=[]; return; % Stop execution instead of warning
else

    %% Reshape array R in order to keep only nodes 
    %% inside n-th shell of neighbours

    R(:,neighbour(n+1):columns(R))=[];   % Reduce array to R(1:5,1:neighbour(n+1)-1)

    neighbour(n+2:length(neighbour))=[]; % Reduce array to neighbour(1:n+1)

    neighbour(n+1)=columns(R); % Last value of this array set to the total number
                               % of nodes inside the n-th shell of neighbours
end

%% OPTIONAL PLOT

if (plot_basis_vectors || plot_primitive_cell || ...
    plot_primitive_cell_centered || plot_lattice_nodes) 
    origin= [0,0,0]';
       
    h = findall(0,'type','figure');
    if isempty(h)
        Title=sprintf('%d lattice nodes within complete shell %s of neighbours',...
                      neighbour(n+1),n);
        fig=figure('NumberTitle', 'off','name',Title);
        k=0; % Legend item counter
    else
        hleg=legend(); % Caution: requires at least one graphical object
                       % inside the current figure window created by the
                       % calling program (at least using initialize_legend3D.m)
        if isempty(hleg)
            k=0;
        else
            Legend = get(legend(),'string'); % Retrieve legend of current figure
            [k,~]=size(Legend); % Legend item counter
        end
    end
    
    if (default_color) 
        color_scheme = get(gca,'colororder');
    end
    
    if (plot_basis_vectors) 
        for i=1:3
            k=k+1; Legend{k}=bvec{i};
            quiver3(origin(1),origin(2),origin(3),a(1,i),a(2,i),a(3,i),...
                    'autoscale','off','color',color_scheme(i,1:3),...
                    'maxheadsize',0.1,...
                    'DisplayName',Legend{k}); hold on;
        end
    end
    
    if (plot_lattice_nodes)
        k=k+1; Legend{k}=[space ' lattice nodes'];
        plot3(T(1,:),T(2,:),T(3,:),'o',...
              'color',color_scheme(1,:),...
              'DisplayName',Legend{k}); hold on;
        switch (n) 
          case 1
            word='first';
          case 2
            word='second';
          case 3
            word='third';
          otherwise
            word=sprintf('%dth',n);
        end
        k=k+1; Legend{k}=['<= ' word ' neighbours'];
        plot3(R(1,:),R(2,:),R(3,:),'o',...
              'MarkerFaceColor',color_scheme(2,:),...
              'DisplayName',Legend{k}); hold on;
    end
    
    if (plot_primitive_cell) 
        k=k+1; Legend{k}='Primitive cell spanned by basis';
        cuboid(a,'Origin',origin,'DisplayName',Legend{k},...
               'ColorMap',color_map)
    end
    
    if (plot_primitive_cell_centered) 
        origin = -(a(1:3,1) + a(1:3,2) + a(1:3,3))/2;
        k=k+1; Legend{k}='Primitive cell centered at origin';
        cuboid(a,'Origin',origin,'DisplayName',Legend{k},...
               'ColorMap','autumn')
    end 
    
    % Axes, Labels & Legend
    
    axis equal; grid on; legend(Legend,'Location','EastOutside');
    
    xlabel(coord{1}); ylabel(coord{2}); zlabel(coord{3});
    
    if(~show_legend)
        legend(gca,'off');
    end
    
end 

end % End of function lattice